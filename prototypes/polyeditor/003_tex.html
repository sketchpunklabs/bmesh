<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><title></title></head>
<style>canvas{ display:block; } body, html { padding:0px; margin:0px; width:100%; height:100%; }</style>
<body><script type="module">
//#region IMPORTS
import useThreeWebGL2, { THREE, useDarkScene, useVisualDebug } from '../_lib/useThreeWebGL2.js';
// import RayCasting, { nearPoint, intersectPlane, nearSegment } from '../_lib/misc/RayCasting.js';

// import { PLYLoader }    from 'three/addons/loaders/PLYLoader.js';

// import DynLineMesh      from '../_lib/meshes/DynLineMesh.js';
// import ShapePointsMesh  from '../_lib/meshes/ShapePointsMesh.js';
//#endregion

//#region MAIN
let App   = useDarkScene( useThreeWebGL2() );
let Ref   = {};
let Debug;

window.addEventListener( 'load', async _=>{
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Setup
    Debug = await useVisualDebug( App );
    App.sphericalLook( 0, 20, 6 );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // const loader = new PLYLoader();
	// loader.load( './pointcloud.ply', geo=>{
    //     const mesh = new THREE.Points( geo, new THREE.PointsMaterial( {size:0.00001, color:0xc0c0c0} ) );
    //     App.scene.add( mesh );
	// } );

    fetchImage( './reference.png' ).then( img=>{ 
        console.log( img.height, img.width );

        const ratio = img.height / img.width;

        const tex   = mkTexture( img, true, false );
        
        const geo   = new THREE.PlaneGeometry( 1, 1 );
        geo.rotateX( Math.PI * -0.5 );
        geo.translate ( 0.5, 0, 0.5 ); 

        const mat   = new THREE.MeshBasicMaterial( {map:tex, color: 0xffffff, side: THREE.DoubleSide} );
        const mesh  = new THREE.Mesh( geo, mat );
        mesh.scale.set( 1, 1, ratio );
        App.scene.add( mesh );
    } );


    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    App.renderLoop();
    // App.createRenderLoop( onPreRender ).start();
});

// function onPreRender( dt, et ){}
// #endregion


function fetchImage( url ){
    return new Promise( async ( resolve, reject )=>{
        const img        = new Image();
        img.crossOrigin	 = 'anonymous';
        img.onload       = ()=>{ resolve( img ); };
        img.onerror      = ()=>{ reject( 'Error loading object url into image' ); };
        img.src          = url;
    });
}

function mkTexture( img, flipY, isRepeat ){
    const tex       = new THREE.Texture( img );
    tex.wrapT       = tex.wrapS = ( isRepeat )? THREE.ClampToEdgeWrapping : THREE.RepeatWrapping;
    tex.flipY       = flipY;
    tex.needsUpdate = true; // Needed, else it may render as black
    return tex;
}

</script></body></html>